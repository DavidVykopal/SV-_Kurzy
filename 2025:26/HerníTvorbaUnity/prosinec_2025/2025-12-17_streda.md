# Hodina - StÅ™eda 17. prosince 2025: DokonÄenÃ­ hry - Build, distribuce a Ãºvod do Unity

## CÃ­le hodiny
- DokonÄit vlastnÃ­ hru v GDevelop
- NauÄit se vytvÃ¡Å™et build (spustitelnou verzi) hry
- NauÄit se distribuovat hru (sdÃ­let s ostatnÃ­mi)
- SeznÃ¡mit se s Unity enginem

## Popis hodiny
Hodina je zamÄ›Å™enÃ¡ na dokonÄenÃ­ her a jejich distribuci. NauÄÃ­me se vytvÃ¡Å™et build hry a distribuovat ji, aby ji mohli hrÃ¡t ostatnÃ­. Na konci hodiny si krÃ¡tce ukÃ¡Å¾eme Unity jako dalÅ¡Ã­ krok v hernÃ­m vÃ½voji.

---

## ğŸ¯ PRÅ®BÄšH HODINY

### 1. Ãšvod - DokonÄenÃ­ a distribuce (5 min)

**Co jsme dÄ›lali:**
- VytvÃ¡Å™eli jsme vlastnÃ­ hry v GDevelop
- Experimentovali s rÅ¯znÃ½mi funkcemi
- UÄili se zÃ¡klady hernÃ­ho vÃ½voje

**Co dnes udÄ›lÃ¡me:**
- DokonÄÃ­me naÅ¡e hry
- VytvoÅ™Ã­me build (spustitelnou verzi)
- NauÄÃ­me se distribuovat hru
- UkÃ¡Å¾eme si Unity

**ProÄ je dÅ¯leÅ¾itÃ©:**
- HotovÃ¡ hra je skvÄ›lÃ¡, ale jeÅ¡tÄ› lepÅ¡Ã­ je ji sdÃ­let
- Build = moÅ¾nost hrÃ¡t hru kdekoli
- Distribuce = moÅ¾nost hrÃ¡t hru s ostatnÃ­mi
- Unity = dalÅ¡Ã­ krok v hernÃ­m vÃ½voji

---

### 2. DokonÄenÃ­ her (15 min)

**Co dokonÄit:**
- Opravit chyby a bugy
- VylepÅ¡it vzhled hry
- PÅ™idat finÃ¡lnÃ­ Ãºpravy
- Otestovat hru kompletnÄ›

**Tipy pro dokonÄenÃ­:**
- ZaÄÃ­t s nejdÅ¯leÅ¾itÄ›jÅ¡Ã­mi vÄ›cmi
- Nezapomenout na testovÃ¡nÃ­
- PoÅ¾Ã¡dat ostatnÃ­ o feedback
- NebÃ¡t se zjednoduÅ¡it, pokud je to potÅ™eba

**Co dÄ›ti dÄ›lajÃ­:**
- DokonÄujÃ­ svÃ© hry
- OpravujÃ­ chyby
- TestujÃ­ hru
- PÅ™ipravujÃ­ se na build

**Lektor:**
- PomÃ¡hÃ¡ s problÃ©my
- DÃ¡vÃ¡ tipy na dokonÄenÃ­
- PomÃ¡hÃ¡ s testovÃ¡nÃ­m
- Povzbuzuje k dokonÄenÃ­

---

### 3. VytvoÅ™enÃ­ buildu (15 min)

**Co je build:**
- SpustitelnÃ¡ verze hry
- MÅ¯Å¾eme ji spustit bez GDevelop
- MÅ¯Å¾eme ji sdÃ­let s ostatnÃ­mi
- MÅ¯Å¾eme ji hrÃ¡t kdekoli

**Jak vytvoÅ™it build v GDevelop:**

**Postup:**
1. **OtevÅ™Ã­t projekt:**
   - OtevÅ™Ã­t svou hru v GDevelop
   - Zkontrolovat, Å¾e vÅ¡e funguje

2. **Exportovat hru:**
   - File â†’ Export â†’ vybrat platformu
   - **Web:** HTML5 (hratelnÃ¡ v prohlÃ­Å¾eÄi)
   - **Windows:** Windows executable (.exe)
   - **Android:** Android APK (pro mobily)
   - **iOS:** iOS (pro iPhone/iPad)

3. **NastavenÃ­ buildu:**
   - NÃ¡zev hry
   - Ikona hry
   - Verze hry
   - DalÅ¡Ã­ metadata

4. **VytvoÅ™enÃ­:**
   - Kliknout na "Export"
   - PoÄkat na dokonÄenÃ­
   - Build je hotovÃ½!

**Co ukÃ¡zat:**
- Postup krok za krokem
- RÅ¯znÃ© moÅ¾nosti exportu
- Jak nastavit build
- Jak otestovat build

**Co dÄ›ti dÄ›lajÃ­:**
- VytvÃ¡Å™ejÃ­ build svÃ© hry
- ZkouÅ¡Ã­ rÅ¯znÃ© platformy
- TestujÃ­ build
- SdÃ­lÃ­ build s ostatnÃ­mi

**Lektor:**
- Ukazuje postup krok za krokem
- PomÃ¡hÃ¡ s problÃ©my
- OdpovÃ­dÃ¡ na otÃ¡zky
- PomÃ¡hÃ¡ s testovÃ¡nÃ­m

---

### 4. Distribuce hry (10 min)

**Co je distribuce:**
- SdÃ­lenÃ­ hry s ostatnÃ­mi
- MoÅ¾nost hrÃ¡t hru kdekoli
- MoÅ¾nost hrÃ¡t hru s pÅ™Ã¡teli

**MoÅ¾nosti distribuce:**

**1. LokÃ¡lnÃ­ sdÃ­lenÃ­:**
- SdÃ­let soubor pÅ™es USB
- SdÃ­let pÅ™es sÃ­Å¥
- SdÃ­let pÅ™es cloud (Google Drive, Dropbox)

**2. Online distribuce:**
- **GDevelop Games:** NahrÃ¡t na GDevelop Games
- **Itch.io:** NahrÃ¡t na Itch.io (platforma pro indie hry)
- **VlastnÃ­ web:** NahrÃ¡t na vlastnÃ­ web

**3. SdÃ­lenÃ­ s pÅ™Ã¡teli:**
- Poslat odkaz
- Poslat soubor
- SdÃ­let na sociÃ¡lnÃ­ch sÃ­tÃ­ch

**PraktickÃ¡ ukÃ¡zka:**
- Jak nahrÃ¡t hru na GDevelop Games
- Jak sdÃ­let odkaz
- Jak sdÃ­let soubor

**Co dÄ›ti dÄ›lajÃ­:**
- DistribuujÃ­ svÃ© hry
- SdÃ­lÃ­ s ostatnÃ­mi
- HrajÃ­ hry ostatnÃ­ch
- DÃ¡vajÃ­ feedback

**Lektor:**
- Ukazuje moÅ¾nosti distribuce
- PomÃ¡hÃ¡ s nahrÃ¡vÃ¡nÃ­m
- PomÃ¡hÃ¡ se sdÃ­lenÃ­m
- Povzbuzuje k distribuci

---

### 5. Ãšvod do Unity (10 min)

**Co je Unity:**
- ProfesionÃ¡lnÃ­ hernÃ­ engine
- PouÅ¾Ã­vÃ¡ se pro 2D i 3D hry
- Velmi vÃ½konnÃ½ a flexibilnÃ­
- PouÅ¾Ã­vÃ¡ se v komerÄnÃ­ch hrÃ¡ch

**ProÄ Unity:**
- VÃ­ce moÅ¾nostÃ­ neÅ¾ GDevelop
- ProfesionÃ¡lnÃ­ nÃ¡stroj
- MoÅ¾nost vytvÃ¡Å™et sloÅ¾itÄ›jÅ¡Ã­ hry
- MoÅ¾nost vytvÃ¡Å™et 3D hry

**ZÃ¡kladnÃ­ rozdÃ­ly:**
- **GDevelop:** JednoduÅ¡Å¡Ã­, vizuÃ¡lnÃ­, rychlejÅ¡Ã­ zaÄÃ¡tek
- **Unity:** SloÅ¾itÄ›jÅ¡Ã­, vÃ­ce moÅ¾nostÃ­, profesionÃ¡lnÃ­

**Co ukÃ¡zat:**
- ZÃ¡kladnÃ­ rozhranÃ­ Unity
- Jak vytvoÅ™it jednoduchou scÃ©nu
- Jak pÅ™idat objekt
- Jak spustit hru

**PraktickÃ¡ ukÃ¡zka:**
- OtevÅ™Ã­t Unity
- UkÃ¡zat rozhranÃ­
- VytvoÅ™it jednoduchou scÃ©nu
- PÅ™idat objekt a pohyb
- Spustit hru

**Co dÄ›ti dÄ›lajÃ­:**
- SledujÃ­ ukÃ¡zku
- PtajÃ­ se na Unity
- ZkouÅ¡Ã­ zÃ¡kladnÃ­ vÄ›ci (pokud je Äas)

**Lektor:**
- Ukazuje Unity krok za krokem
- VysvÄ›tluje zÃ¡kladnÃ­ pojmy
- OdpovÃ­dÃ¡ na otÃ¡zky
- PÅ™ipravuje na budoucÃ­ prÃ¡ci s Unity

---

### 6. ShrnutÃ­ a plÃ¡ny do budoucna (5 min)

**Co jsme se nauÄili:**
- DokonÄovat hry
- VytvÃ¡Å™et build
- Distribuovat hry
- ZÃ¡klady Unity

**Co nÃ¡s ÄekÃ¡:**
- V lednu zaÄneme s Unity
- NauÄÃ­me se vytvÃ¡Å™et 3D hry
- NauÄÃ­me se vytvÃ¡Å™et sloÅ¾itÄ›jÅ¡Ã­ hry
- PokraÄujeme v hernÃ­m vÃ½voji

**Co si pÅ™ipravit:**
- Unity nainstalovanÃ© (pokud je moÅ¾nÃ©)
- PÅ™ipravenÃ© nÃ¡pady na hry
- PÅ™ipravenÃ© na prÃ¡ci s Unity

---

## ğŸ’¡ KLÃÄŒOVÃ‰ POJMY

- **Build:** SpustitelnÃ¡ verze hry
- **Export:** VytvoÅ™enÃ­ buildu z projektu
- **Distribuce:** SdÃ­lenÃ­ hry s ostatnÃ­mi
- **Platforma:** SystÃ©m, na kterÃ©m hra bÄ›Å¾Ã­ (Windows, Android, Web)
- **Unity:** ProfesionÃ¡lnÃ­ hernÃ­ engine
- **Engine:** NÃ¡stroj pro vytvÃ¡Å™enÃ­ her

---

## ğŸ”— PROPOJENÃ S BUDOUCÃMI HODINAMI

**Unity od ledna:**
- ZaÄneme pracovat s Unity
- NauÄÃ­me se vytvÃ¡Å™et 3D hry
- NauÄÃ­me se vytvÃ¡Å™et sloÅ¾itÄ›jÅ¡Ã­ hry
- PokraÄujeme v hernÃ­m vÃ½voji

**ProÄ je dÅ¯leÅ¾itÃ©:**
- Unity = dalÅ¡Ã­ krok v hernÃ­m vÃ½voji
- VÃ­ce moÅ¾nostÃ­ pro vytvÃ¡Å™enÃ­ her
- ProfesionÃ¡lnÃ­ nÃ¡stroj
- MoÅ¾nost vytvÃ¡Å™et sloÅ¾itÄ›jÅ¡Ã­ hry

---

## ğŸ  DOMÃCÃ ÃšKOL (dobrovolnÃ½)

- DokonÄit hru a vytvoÅ™it build
- Distribuovat hru a zÃ­skat feedback
- Prozkoumat Unity (pokud je moÅ¾nÃ©)
- PÅ™inÃ©st nÃ¡pad na hru, kterou by chtÄ›li vytvoÅ™it v Unity

---

## ğŸ“ POZNÃMKY PRO DAVIDA

### PÅ™Ã­prava:
- [ ] OvÄ›Å™it, Å¾e GDevelop funguje sprÃ¡vnÄ›
- [ ] PÅ™ipravit ukÃ¡zku vytvÃ¡Å™enÃ­ buildu
- [ ] PÅ™ipravit ukÃ¡zku distribuce
- [ ] PÅ™ipravit Unity k ukÃ¡zce
- [ ] PÅ™ipravit tipy a triky

### BÄ›hem hodiny:
- **DokonÄenÃ­:** PomÃ¡hat s dokonÄenÃ­m her
- **Build:** UkÃ¡zat postup krok za krokem
- **Distribuce:** UkÃ¡zat moÅ¾nosti distribuce
- **Unity:** UkÃ¡zat zÃ¡kladnÃ­ vÄ›ci jasnÄ›

### ÄŒasovÃ¡nÃ­:
- Ãšvod: 5 min
- DokonÄenÃ­ her: 15 min
- VytvoÅ™enÃ­ buildu: 15 min
- Distribuce: 10 min
- Ãšvod do Unity: 10 min
- ShrnutÃ­: 5 min
- Buffer: 5 min

### Tipy:
- DokonÄenÃ­ mÅ¯Å¾e bÃ½t nÃ¡roÄnÃ© - pomÃ¡hat s prioritami
- Build mÅ¯Å¾e bÃ½t sloÅ¾itÃ© - ukÃ¡zat krok za krokem
- Distribuce je dÅ¯leÅ¾itÃ¡ - povzbuzovat k sdÃ­lenÃ­
- Unity je novÃ© - zaÄÃ­t jednoduÅ¡e

### DÅ¯leÅ¾itÃ©:
- Ujistit se, Å¾e vÅ¡ichni dokonÄili hru nebo majÃ­ plÃ¡n
- UkÃ¡zat build prakticky
- UkÃ¡zat distribuci prakticky
- PÅ™ipravit na Unity - nadchnout pro pÅ™Ã­Å¡tÃ­ hodiny

---

## ğŸ® BONUS: Arduino hry na LCD Keypad Shield

**Pro ty, kteÅ™Ã­ chtÄ›jÃ­ zkusit nÄ›co jinÃ©ho:**

Na konci hodiny si mÅ¯Å¾eme zkusit vytvoÅ™it jednoduchÃ© hry na Arduino Uno s LCD Keypad Shield. Shield mÃ¡ **LCD displej 16x2** (2 Å™Ã¡dky po 16 znacÃ­ch) a 5 tlaÄÃ­tek (Select, Left, Down, Up, Right).

**DÅ¯leÅ¾itÃ©:** VÅ¡echny hry jsou navrÅ¾enÃ© pro 16x2 display - Å™Ã¡dky jsou indexovanÃ© 0-1, sloupce 0-15.

### ZÃ¡kladnÃ­ setup

**PotÅ™ebnÃ© knihovny:**
```cpp
#include <LiquidCrystal_I2C.h>
#include <Wire.h>
```

**PlatformIO konfigurace (platformio.ini):**
```ini
lib_deps = marcoschwartz/LiquidCrystal_I2C@^1.1.4
```

**ZÃ¡kladnÃ­ kÃ³d pro inicializaci LCD a ÄtenÃ­ tlaÄÃ­tek:**
```cpp
// LCD Keypad Shield s I2C
// Adresa I2C je obvykle 0x27 nebo 0x3F (zkontroluj pomocÃ­ I2C scanneru)
LiquidCrystal_I2C lcd(0x27, 16, 2); // (adresa, sloupce, Å™Ã¡dky)

void setup() {
  Wire.begin();
  lcd.init();
  lcd.backlight();
  lcd.clear();
}

// TlaÄÃ­tka na analogovÃ©m pinu A0
int readButtons() {
  int adc_key_in = analogRead(0);
  
  if (adc_key_in > 1000) return 0; // Å½Ã¡dnÃ© tlaÄÃ­tko
  if (adc_key_in < 50)   return 1; // Select
  if (adc_key_in < 200)  return 2; // Left
  if (adc_key_in < 400)  return 3; // Up
  if (adc_key_in < 600)  return 4; // Down
  if (adc_key_in < 800)  return 5; // Right
  
  return 0;
}
```

**PoznÃ¡mka:** Pokud LCD nefunguje, zkus zmÄ›nit adresu I2C z `0x27` na `0x3F` nebo pouÅ¾ij I2C scanner k nalezenÃ­ sprÃ¡vnÃ© adresy.

---

### Hra 1: Snake (Had)

**CÃ­l:** SbÃ­rat jÃ­dlo a rÅ¯st, vyhÃ½bat se stÄ›nÃ¡m a vlastnÃ­mu tÄ›lu.

```cpp
#include <LiquidCrystal_I2C.h>
#include <Wire.h>

LiquidCrystal_I2C lcd(0x27, 16, 2); // (adresa I2C, sloupce, Å™Ã¡dky)

// Had
int snakeX[32], snakeY[32];
int snakeLength = 3;
int direction = 3; // 1=up, 2=down, 3=right, 4=left
int foodX, foodY;
int score = 0;

void setup() {
  Wire.begin();
  lcd.init();
  lcd.backlight();
  lcd.clear();
  randomSeed(analogRead(1));
  
  // Inicializace hada
  for (int i = 0; i < snakeLength; i++) {
    snakeX[i] = 5 - i;
    snakeY[i] = 0;
  }
  
  spawnFood();
  drawGame();
}

void loop() {
  int button = readButtons();
  
  // ZmÄ›na smÄ›ru
  if (button == 3 && direction != 2) direction = 1; // Up
  if (button == 4 && direction != 1) direction = 2; // Down
  if (button == 5 && direction != 4) direction = 3; // Right
  if (button == 2 && direction != 3) direction = 4; // Left
  
  // Pohyb hlavy
  int newX = snakeX[0];
  int newY = snakeY[0];
  
  if (direction == 1) newY--;
  if (direction == 2) newY++;
  if (direction == 3) newX++;
  if (direction == 4) newX--;
  
  // Kontrola kolize se stÄ›nami
  if (newX < 0 || newX >= 16 || newY < 0 || newY >= 2) {
    gameOver();
    return;
  }
  
  // Kontrola kolize s tÄ›lem
  for (int i = 0; i < snakeLength; i++) {
    if (snakeX[i] == newX && snakeY[i] == newY) {
      gameOver();
      return;
    }
  }
  
  // Kontrola jÃ­dla
  if (newX == foodX && newY == foodY) {
    snakeLength++;
    score++;
    spawnFood();
  } else {
    // OdstranÄ›nÃ­ ocasu
    for (int i = snakeLength - 1; i > 0; i--) {
      snakeX[i] = snakeX[i-1];
      snakeY[i] = snakeY[i-1];
    }
  }
  
  // Aktualizace hlavy
  snakeX[0] = newX;
  snakeY[0] = newY;
  
  drawGame();
  delay(300);
}

void spawnFood() {
  do {
    foodX = random(16);
    foodY = random(2);
  } while (isSnakePosition(foodX, foodY));
}

bool isSnakePosition(int x, int y) {
  for (int i = 0; i < snakeLength; i++) {
    if (snakeX[i] == x && snakeY[i] == y) return true;
  }
  return false;
}

void drawGame() {
  lcd.clear();
  // Pole pro 2 Å™Ã¡dky po 16 znacÃ­ch (17 vÄetnÄ› null terminatoru)
  char screen[2][17] = {"                ", "                "};
  
  // KreslenÃ­ hada (Å™Ã¡dek 0 nebo 1, sloupec 0-15)
  for (int i = 0; i < snakeLength; i++) {
    screen[snakeY[i]][snakeX[i]] = 'O';
  }
  screen[snakeY[0]][snakeX[0]] = '@'; // Hlava
  
  // KreslenÃ­ jÃ­dla
  screen[foodY][foodX] = '*';
  
  // ZobrazenÃ­ na LCD (Å™Ã¡dek 0 a 1)
  lcd.setCursor(0, 0);
  lcd.print(screen[0]);
  lcd.setCursor(0, 1);
  lcd.print(screen[1]);
  
  // SkÃ³re (pozice 12-15 na prvnÃ­m Å™Ã¡dku)
  lcd.setCursor(12, 0);
  lcd.print(score);
}

void gameOver() {
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("Game Over!");
  lcd.setCursor(0, 1);
  lcd.print("Score: ");
  lcd.print(score);
  delay(3000);
  
  // Reset
  snakeLength = 3;
  score = 0;
  direction = 3;
  for (int i = 0; i < snakeLength; i++) {
    snakeX[i] = 5 - i;
    snakeY[i] = 0;
  }
  spawnFood();
}

int readButtons() {
  int adc_key_in = analogRead(0);
  if (adc_key_in > 1000) return 0;
  if (adc_key_in < 50)   return 1; // Select
  if (adc_key_in < 200)  return 2; // Left
  if (adc_key_in < 400)  return 3; // Up
  if (adc_key_in < 600)  return 4; // Down
  if (adc_key_in < 800)  return 5; // Right
  return 0;
}
```

---

### Hra 2: Reaction Game (ReakÄnÃ­ hra)

**CÃ­l:** Stisknout sprÃ¡vnÃ© tlaÄÃ­tko co nejrychleji, kdyÅ¾ se objevÃ­ Å¡ipka.

```cpp
#include <LiquidCrystal_I2C.h>
#include <Wire.h>

LiquidCrystal_I2C lcd(0x27, 16, 2); // (adresa I2C, sloupce, Å™Ã¡dky)

int score = 0;
int roundNum = 0;
unsigned long startTime;
int reactionTime;

void setup() {
  Wire.begin();
  lcd.init();
  lcd.backlight();
  lcd.clear();
  randomSeed(analogRead(1));
  lcd.print("Reaction Game!");
  delay(2000);
  newRound();
}

void loop() {
  int button = readButtons();
  
  if (button > 0) {
    // Kontrola sprÃ¡vnÃ©ho tlaÄÃ­tka
    int correctButton = getCorrectButton();
    if (button == correctButton) {
      reactionTime = millis() - startTime;
      score += max(0, 1000 - reactionTime / 10);
      showResult(true);
    } else {
      showResult(false);
    }
    delay(2000);
    newRound();
  }
  
  // Timeout po 3 sekundÃ¡ch
  if (millis() - startTime > 3000) {
    showResult(false);
    delay(2000);
    newRound();
  }
}

void newRound() {
  roundNum++;
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("Round: ");
  lcd.print(roundNum);
  lcd.setCursor(0, 1);
  lcd.print("Get ready...");
  
  delay(random(1000, 3000)); // NÃ¡hodnÃ© zpoÅ¾dÄ›nÃ­
  
  int direction = random(2, 6); // 2=Left, 3=Up, 4=Down, 5=Right
  lcd.clear();
  lcd.setCursor(7, 0);
  
  switch(direction) {
    case 2: lcd.print("<"); break;
    case 3: lcd.print("^"); break;
    case 4: lcd.print("v"); break;
    case 5: lcd.print(">"); break;
  }
  
  lcd.setCursor(0, 1);
  lcd.print("Press button!");
  
  startTime = millis();
  setCorrectButton(direction);
}

int correctButton = 0;

void setCorrectButton(int btn) {
  correctButton = btn;
}

int getCorrectButton() {
  return correctButton;
}

void showResult(bool correct) {
  lcd.clear();
  if (correct) {
    lcd.setCursor(0, 0);
    lcd.print("Correct!");
    lcd.setCursor(0, 1);
    lcd.print("Time: ");
    lcd.print(reactionTime);
    lcd.print("ms");
  } else {
    lcd.setCursor(0, 0);
    lcd.print("Wrong/Timeout!");
  }
  lcd.setCursor(10, 1);
  lcd.print("S:");
  lcd.print(score);
}

int readButtons() {
  int adc_key_in = analogRead(0);
  if (adc_key_in > 1000) return 0;
  if (adc_key_in < 50)   return 1;
  if (adc_key_in < 200)  return 2;
  if (adc_key_in < 400)  return 3;
  if (adc_key_in < 600)  return 4;
  if (adc_key_in < 800)  return 5;
  return 0;
}
```

---

### Hra 3: Pong

**CÃ­l:** OdrÃ¡Å¾et mÃ­Äek pÃ¡dlem a zÃ­skat body.

```cpp
#include <LiquidCrystal_I2C.h>
#include <Wire.h>

LiquidCrystal_I2C lcd(0x27, 16, 2); // (adresa I2C, sloupce, Å™Ã¡dky)

int ballX = 8, ballY = 0;
int ballDirX = 1, ballDirY = 1;
int paddlePos = 7;
int score = 0;
int lives = 3;

void setup() {
  Wire.begin();
  lcd.init();
  lcd.backlight();
  lcd.clear();
  randomSeed(analogRead(1));
  lcd.print("Pong Game!");
  delay(2000);
}

void loop() {
  int button = readButtons();
  
  // OvlÃ¡dÃ¡nÃ­ pÃ¡dla
  if (button == 2 && paddlePos > 0) paddlePos--; // Left
  if (button == 5 && paddlePos < 14) paddlePos++; // Right
  
  // Pohyb mÃ­Äku
  ballX += ballDirX;
  ballY += ballDirY;
  
  // Odraz od stÄ›n
  if (ballX <= 0 || ballX >= 15) ballDirX = -ballDirX;
  if (ballY <= 0) ballDirY = -ballDirY;
  
  // Kontrola kolize s pÃ¡dlem
  if (ballY >= 1 && ballX >= paddlePos && ballX <= paddlePos + 2) {
    ballDirY = -ballDirY;
    score++;
  }
  
  // ZtrÃ¡ta Å¾ivota
  if (ballY >= 2) {
    lives--;
    if (lives <= 0) {
      gameOver();
      return;
    }
    resetBall();
  }
  
  drawGame();
  delay(150);
}

void resetBall() {
  ballX = 8;
  ballY = 0;
  ballDirX = random(0, 2) ? 1 : -1;
  ballDirY = 1;
  delay(1000);
}

void drawGame() {
  lcd.clear();
  
  // HornÃ­ Å™Ã¡dek (Å™Ã¡dek 0) - mÃ­Äek (pozice 0-15)
  lcd.setCursor(ballX, ballY);
  lcd.print("O");
  
  // SpodnÃ­ Å™Ã¡dek (Å™Ã¡dek 1) - pÃ¡dlo (pozice 0-15)
  lcd.setCursor(paddlePos, 1);
  lcd.print("===");
  
  // SkÃ³re a Å¾ivoty na prvnÃ­m Å™Ã¡dku (16 znakÅ¯ celkem)
  lcd.setCursor(0, 0);
  lcd.print("S:");
  lcd.print(score);
  lcd.setCursor(10, 0);
  lcd.print("L:");
  lcd.print(lives);
}

void gameOver() {
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("Game Over!");
  lcd.setCursor(0, 1);
  lcd.print("Final: ");
  lcd.print(score);
  delay(3000);
  
  // Reset
  score = 0;
  lives = 3;
  paddlePos = 7;
  resetBall();
}

int readButtons() {
  int adc_key_in = analogRead(0);
  if (adc_key_in > 1000) return 0;
  if (adc_key_in < 50)   return 1;
  if (adc_key_in < 200)  return 2;
  if (adc_key_in < 400)  return 3;
  if (adc_key_in < 600)  return 4;
  if (adc_key_in < 800)  return 5;
  return 0;
}
```

---

### Hra 4: Memory Game (PamÄ›Å¥ovÃ¡ hra)

**CÃ­l:** Zapamatovat si sekvenci tlaÄÃ­tek a zopakovat ji.

```cpp
#include <LiquidCrystal_I2C.h>
#include <Wire.h>

LiquidCrystal_I2C lcd(0x27, 16, 2); // (adresa I2C, sloupce, Å™Ã¡dky)

int sequence[10];
int sequenceLength = 1;
int currentStep = 0;
int playerStep = 0;
bool showingSequence = true;
int score = 0;

void setup() {
  Wire.begin();
  lcd.init();
  lcd.backlight();
  lcd.clear();
  randomSeed(analogRead(1));
  generateSequence();
  showSequence();
}

void loop() {
  if (showingSequence) {
    // ZobrazovÃ¡nÃ­ sekvence
    return;
  }
  
  int button = readButtons();
  if (button > 1 && button <= 5) { // Ignorovat Select
    checkButton(button);
  }
}

void generateSequence() {
  for (int i = 0; i < 10; i++) {
    sequence[i] = random(2, 6); // 2-5 (Left, Up, Down, Right)
  }
}

void showSequence() {
  showingSequence = true;
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("Watch!");
  
  for (int i = 0; i < sequenceLength; i++) {
    lcd.setCursor(7, 1);
    switch(sequence[i]) {
      case 2: lcd.print("<"); break;
      case 3: lcd.print("^"); break;
      case 4: lcd.print("v"); break;
      case 5: lcd.print(">"); break;
    }
    delay(800);
    lcd.setCursor(7, 1);
    lcd.print(" ");
    delay(200);
  }
  
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("Your turn!");
  showingSequence = false;
  playerStep = 0;
}

void checkButton(int button) {
  if (button == sequence[playerStep]) {
    playerStep++;
    lcd.setCursor(0, 1);
    lcd.print("Correct!");
    delay(500);
    
    if (playerStep >= sequenceLength) {
      // ÃšspÄ›Å¡nÄ› dokonÄeno
      score += sequenceLength * 10;
      sequenceLength++;
      lcd.clear();
      lcd.setCursor(0, 0);
      lcd.print("Level ");
      lcd.print(sequenceLength);
      lcd.print("!");
      delay(1500);
      
      if (sequenceLength > 10) {
        gameWon();
        return;
      }
      
      showSequence();
    }
  } else {
    // Å patnÄ›
    gameOver();
  }
}

void gameOver() {
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("Wrong!");
  lcd.setCursor(0, 1);
  lcd.print("Score: ");
  lcd.print(score);
  delay(3000);
  
  // Reset
  sequenceLength = 1;
  score = 0;
  generateSequence();
  showSequence();
}

void gameWon() {
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("You won!");
  lcd.setCursor(0, 1);
  lcd.print("Score: ");
  lcd.print(score);
  delay(3000);
  
  sequenceLength = 1;
  score = 0;
  generateSequence();
  showSequence();
}

int readButtons() {
  int adc_key_in = analogRead(0);
  if (adc_key_in > 1000) return 0;
  if (adc_key_in < 50)   return 1;
  if (adc_key_in < 200)  return 2;
  if (adc_key_in < 400)  return 3;
  if (adc_key_in < 600)  return 4;
  if (adc_key_in < 800)  return 5;
  return 0;
}
```

---

### Hra 5: Simple Platformer (JednoduchÃ½ platformer)

**CÃ­l:** PÅ™eskoÄit pÅ™ekÃ¡Å¾ky a zÃ­skat body.

```cpp
#include <LiquidCrystal_I2C.h>
#include <Wire.h>

LiquidCrystal_I2C lcd(0x27, 16, 2); // (adresa I2C, sloupce, Å™Ã¡dky)

int playerX = 2;
int playerY = 1;
bool isJumping = false;
int jumpCounter = 0;
int obstacleX = 15;
int obstacleSpeed = 1;
int score = 0;
int gameSpeed = 200;

void setup() {
  Wire.begin();
  lcd.init();
  lcd.backlight();
  lcd.clear();
  randomSeed(analogRead(1));
  lcd.print("Platformer!");
  delay(2000);
}

void loop() {
  int button = readButtons();
  
  // Skok
  if (button == 3 && !isJumping && playerY == 1) { // Up
    isJumping = true;
    jumpCounter = 0;
  }
  
  // Animace skoku
  if (isJumping) {
    jumpCounter++;
    if (jumpCounter < 3) {
      playerY = 0;
    } else {
      playerY = 1;
      isJumping = false;
      jumpCounter = 0;
    }
  }
  
  // Pohyb pÅ™ekÃ¡Å¾ky
  obstacleX -= obstacleSpeed;
  if (obstacleX < 0) {
    obstacleX = 15;
    score++;
    if (score % 5 == 0 && gameSpeed > 100) {
      gameSpeed -= 10; // ZrychlenÃ­
    }
  }
  
  // Kontrola kolize
  if (obstacleX == playerX && playerY == 1) {
    gameOver();
    return;
  }
  
  drawGame();
  delay(gameSpeed);
}

void drawGame() {
  lcd.clear();
  
  // HrÃ¡Ä (Å™Ã¡dek 0 nebo 1, sloupec 0-15)
  lcd.setCursor(playerX, playerY);
  lcd.print("@");
  
  // PÅ™ekÃ¡Å¾ka na spodnÃ­m Å™Ã¡dku (Å™Ã¡dek 1)
  lcd.setCursor(obstacleX, 1);
  lcd.print("#");
  
  // ZemÄ› na spodnÃ­m Å™Ã¡dku (16 znakÅ¯, pozice 0-15)
  for (int i = 0; i < 16; i++) {
    lcd.setCursor(i, 1);
    if (i != playerX && i != obstacleX) {
      lcd.print("_");
    }
  }
  
  // SkÃ³re na hornÃ­m Å™Ã¡dku (pozice 10-15)
  lcd.setCursor(10, 0);
  lcd.print("S:");
  lcd.print(score);
}

void gameOver() {
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("Game Over!");
  lcd.setCursor(0, 1);
  lcd.print("Score: ");
  lcd.print(score);
  delay(3000);
  
  // Reset
  playerX = 2;
  playerY = 1;
  isJumping = false;
  obstacleX = 15;
  obstacleSpeed = 1;
  score = 0;
  gameSpeed = 200;
}

int readButtons() {
  int adc_key_in = analogRead(0);
  if (adc_key_in > 1000) return 0;
  if (adc_key_in < 50)   return 1;
  if (adc_key_in < 200)  return 2;
  if (adc_key_in < 400)  return 3;
  if (adc_key_in < 600)  return 4;
  if (adc_key_in < 800)  return 5;
  return 0;
}
```

---

### Tipy pro prÃ¡ci s kÃ³dem:

1. **Knihovna:** Ujisti se, Å¾e mÃ¡Å¡ nainstalovanou knihovnu `LiquidCrystal_I2C` pÅ™es PlatformIO (`lib_deps = marcoschwartz/LiquidCrystal_I2C@^1.1.4`)
2. **I2C adresa:** Pokud LCD nefunguje, zkus zmÄ›nit adresu z `0x27` na `0x3F` nebo pouÅ¾ij I2C scanner k nalezenÃ­ sprÃ¡vnÃ© adresy
3. **Wire.begin():** NezapomeÅˆ pÅ™idat `Wire.begin()` v `setup()` pro inicializaci I2C komunikace
4. **Kalibrace tlaÄÃ­tek:** Hodnoty analogovÃ©ho ÄtenÃ­ se mohou liÅ¡it - mÅ¯Å¾eÅ¡ je upravit podle svÃ©ho shieldu
5. **Optimalizace:** Pro lepÅ¡Ã­ vÃ½kon mÅ¯Å¾eÅ¡ upravit rychlost her (delay hodnoty)
6. **RozÅ¡Ã­Å™enÃ­:** MÅ¯Å¾eÅ¡ pÅ™idat dalÅ¡Ã­ funkce - zvuky, vÃ­ce ÃºrovnÃ­, lepÅ¡Ã­ grafiku

**I2C Scanner (pokud potÅ™ebujeÅ¡ zjistit adresu LCD):**
```cpp
#include <Wire.h>

void setup() {
  Wire.begin();
  Serial.begin(9600);
  Serial.println("I2C Scanner");
}

void loop() {
  byte error, address;
  int nDevices = 0;
  
  for(address = 1; address < 127; address++ ) {
    Wire.beginTransmission(address);
    error = Wire.endTransmission();
    
    if (error == 0) {
      Serial.print("I2C device found at address 0x");
      if (address<16) Serial.print("0");
      Serial.print(address,HEX);
      Serial.println("  !");
      nDevices++;
    }
  }
  
  if (nDevices == 0) Serial.println("No I2C devices found\n");
  delay(5000);
}
```

**VÃ½zva:** Zkus vytvoÅ™it vlastnÃ­ hru kombinujÃ­cÃ­ prvky z tÄ›chto her!
